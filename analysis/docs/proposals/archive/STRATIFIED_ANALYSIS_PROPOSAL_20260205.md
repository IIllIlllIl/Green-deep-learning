# 分层因果分析方案

**版本**: 1.0
**日期**: 2026-02-05
**作者**: 资深科研工作者 (Claude Code)
**方案类型**: 因果推断分析扩展
**状态**: 📋 待审查

---

## 执行摘要

本方案提出按训练场景（`is_parallel`）进行分层因果分析，以丰富我们对训练场景和权衡关系影响的理解。通过将数据分为并行和非并行两个子集，分别执行DiBS因果图学习、ATE计算和权衡检测，我们期望验证交互项分析中发现的现象，并揭示更细粒度的场景依赖因果机制。

**核心目标**:
- 验证交互项发现的调节效应
- 揭示并行/非并行场景下的差异化因果结构
- 提供更精准的场景特定优化建议

**分析范围**: 4组数据（group1, group3, group5, group6），共656样本

---

## 1. 研究背景与动机

### 1.1 现有发现

通过交互项调节效应分析（`INTERACTION_EFFECT_ANALYSIS_REPORT_20260205.md`），我们发现：

1. **交互项揭示新权衡**: 37条交互项因果边，产生34个权衡
2. **效应强度放大**: 并行场景下epochs对GPU能耗影响增强1.87倍
3. **场景依赖性**: 原始超参数往往无显著效应，但交互项显示强烈权衡

### 1.2 研究问题

**核心问题**: 不同训练场景（并行/非并行）下的因果结构和权衡关系有何差异？

**子问题**:
1. 并行/非并行场景的因果图结构是否不同？
2. 同一超参数在不同场景下的ATE效应是否不同？
3. 不同场景的权衡关系模式有何差异？
4. 哪些因果效应是场景通用的，哪些是场景特定的？

### 1.3 分层分析的价值

**相比交互项分析的优势**:
- ✅ **直接建模**: 分别学习两个场景的因果图，而非通过交互项
- ✅ **结构差异**: 可发现不同场景下的因果结构变化
- ✅ **效应对比**: 直接对比同一边在不同场景的ATE
- ✅ **验证机制**: 验证交互项发现的稳健性

**相比全局分析的差异**:
- 全局分析: 混合两个场景，平均效应可能掩盖差异
- 分层分析: 分别建模，揭示场景特定机制

---

## 2. 数据准备

### 2.1 分层变量选择

**分层变量**: `is_parallel` (布尔值)
- `True`: 并行训练场景
- `False`: 非并行训练场景

**选择理由**:
1. **理论依据**: 并行训练显著改变计算资源利用模式
2. **实证支持**: 交互项分析已证实其调节效应
3. **数据可行性**: 所有组均有该变量，且分布较均衡
4. **实践价值**: 直接指导场景特定的超参数调优

### 2.2 分层组选择

**数据量检查结果**:

| 组ID | 总样本 | True (并行) | False (非并行) | False比例 | 适合分层 |
|------|--------|------------|---------------|----------|---------|
| group1_examples | 304 | 178 | 126 | 41.4% | ✅ 是 |
| group2_vulberta | 72 | 47 | **25** | 34.7% | ⚠️ 否 |
| group3_person_reid | 206 | 113 | 93 | 45.1% | ✅ 是 |
| group4_bug_localization | 90 | 65 | **25** | 27.7% | ⚠️ 否 |
| group5_mrt_oast | 72 | 36 | 36 | 50.0% | ✅ 是 |
| group6_resnet | 74 | 43 | 31 | 41.8% | ✅ 是 |

**筛选标准**: 每层样本数 ≥ 30（建议DiBS学习至少50样本，但30是最低阈值）

**最终选择**: **4组**
- ✅ group1_examples (304样本): 178 True + 126 False
- ✅ group3_person_reid (206样本): 113 True + 93 False
- ✅ group5_mrt_oast (72样本): 36 True + 36 False
- ✅ group6_resnet (74样本): 43 True + 31 False

**排除组**: 2组
- ❌ group2_vulberta: False层仅25样本
- ❌ group4_bug_localization: False层仅25样本

### 2.3 数据分割计划

**输入数据**: `analysis/data/energy_research/6groups_global_std/{group}_global_std.csv`

**输出数据结构**:
```
analysis/data/energy_research/stratified/
├── group1_examples/
│   ├── group1_examples_parallel_true_global_std.csv    (178样本)
│   └── group1_examples_parallel_false_global_std.csv   (126样本)
├── group3_person_reid/
│   ├── group3_person_reid_parallel_true_global_std.csv  (113样本)
│   └── group3_person_reid_parallel_false_global_std.csv (93样本)
├── group5_mrt_oast/
│   ├── group5_mrt_oast_parallel_true_global_std.csv     (36样本)
│   └── group5_mrt_oast_parallel_false_global_std.csv    (36样本)
└── group6_resnet/
    ├── group6_resnet_parallel_true_global_std.csv       (43样本)
    ├── group6_resnet_parallel_false_global_std.csv      (31样本)
```

**数据预处理要求**:
1. 保留全局标准化参数（使用已有的标准化）
2. 移除交互项列（`_x_is_parallel`），因为分层后它们是冗余的
3. 保留所有原始变量（能耗、性能、超参数、模型架构）
4. 确保每层数据质量（检查缺失值、异常值）

---

## 3. 分析流程

### 3.1 流程概览

```
数据分割
    ↓
DiBS因果图学习 (8个独立模型)
    ↓
ATE计算 (每个因果图)
    ↓
权衡检测 (算法1)
    ↓
对比分析 (跨场景对比)
```

### 3.2 详细步骤

#### 步骤1: 数据分割与验证

**输入**: 4组的全局标准化数据
**输出**: 8个分层子集（4组 × 2层）

**操作**:
1. 按 `is_parallel` 列分割数据
2. 移除冗余列（交互项、is_parallel标志本身）
3. 验证每层数据质量（样本数、列数、缺失值）
4. 生成数据分割报告

**验收标准**:
- ✅ 每层数据完整性 > 95%
- ✅ 无缺失值或已合理填补
- ✅ 特征数量一致（除移除的交互项外）

#### 步骤2: DiBS因果图学习

**输入**: 8个分层子集
**输出**: 8个DiBS因果图（邻接矩阵 + 边列表）

**参数配置**:
```python
DiBS_CONFIG = {
    'prior_type': 'sf',           # Scale-free prior
    'graph_prior_scale': 1.0,     # 与全局分析一致
    'sampling_iterations': 1000,   # 与全局分析一致
    'burnin': 200,                # 与全局分析一致
    'num_graph_samples': 100,     # 与全局分析一致
    'threshold': 0.3              # 强边筛选阈值
}
```

**注意事项**:
- ⚠️ 小样本组（group5/6, 30-40样本）可能需要调整参数或增加采样
- ⚠️ 需要监控DiBS收敛性（检查trace plots）
- ⚠️ 可能需要调整 `graph_prior_scale` 适应小样本

**验收标准**:
- ✅ DiBS成功收敛（无错误/警告）
- ✅ 每个因果图至少有10条强边（threshold=0.3）
- ✅ 边的合理性检查（无明显的虚假边）

#### 步骤3: ATE计算

**输入**: 8个DiBS因果图 + 对应的分层子集
**输出**: 8个ATE结果文件（CSV + JSON摘要）

**方法**: 与全局分析一致的DML方法
```python
CausalInferenceEngine.estimate_ate(
    method='dml',
    model_phi=MLP,
    model_rho=MLP,
    n_splits=5,
    confidence_level=0.95
)
```

**质量控制**:
- 只保留统计显著的边（`is_significant=True`）
- 使用修复后的CI计算方法（`ate_inference()`）
- 记录混淆因素数量

**验收标准**:
- ✅ 所有CI宽度 > 0（无CI缺陷）
- ✅ 至少50%的边有有效ATE
- ✅ 显著边的比例 > 30%

#### 步骤4: 权衡检测

**输入**: 8个ATE结果
**输出**: 8个权衡检测文件 + 对比分析

**方法**: 算法1（CTF论文），使用相同的 `ENERGY_PERF_RULES`

**对比维度**:
1. **场景内对比**: 并行场景内的权衡模式
2. **跨场景对比**: 同一组在不同场景的权衡差异
3. **超参数对比**: 同一超参数在不同场景的权衡差异

**验收标准**:
- ✅ 权衡检测执行成功，无错误
- ✅ 能识别至少若干能耗vs性能权衡
- ✅ 结果可跨场景对比

#### 步骤5: 对比分析与报告

**输入**: 所有分层结果 + 全局分析结果（基线）

**输出**: 综合分析报告 + 可视化

**分析内容**:

1. **因果图结构对比**:
   - 并行 vs 非并行的边数差异
   - 共同边 vs 场景特定边
   - 边强度分布差异

2. **ATE效应对比**:
   - 同一边在不同场景的ATE值和CI
   - 效应方向是否改变
   - 效应强度是否不同

3. **权衡关系对比**:
   - 并行场景的权衡数量和类型
   - 非并行场景的权衡数量和类型
   - 能耗vs性能权衡的场景差异

4. **验证交互项发现**:
   - 交互项预测的调节效应是否在分层分析中重现
   - 效应放大是否在直接对比中确认

---

## 4. 预期结果

### 4.1 可能发现

**假设1: 因果结构差异**
- 并行场景可能有更多GPU相关的因果边
- 非并行场景可能有更多CPU相关的因果边
- 某些超参数只在特定场景中有因果效应

**假设2: ATE效应差异**
- 同一超参数在不同场景的ATE大小不同
- 某些效应在并行场景更强（如epochs→GPU能耗）
- 某些效应可能方向相反

**假设3: 权衡关系差异**
- 并行场景可能有更多能耗vs性能权衡
- 非并行场景的权衡可能更温和
- 某些权衡只存在于特定场景

### 4.2 预期输出

**数据输出**:
```
analysis/results/energy_research/stratified/
├── dibs/
│   ├── group1_examples_parallel_true/
│   ├── group1_examples_parallel_false/
│   ├── ... (8个子目录)
├── ate/
│   ├── {group}_parallel_true_dibs_ate.csv
│   ├── {group}_parallel_false_dibs_ate.csv
│   └── ... (8个文件)
└── tradeoffs/
    ├── {group}_parallel_true_tradeoffs.csv
    ├── {group}_parallel_false_tradeoffs.csv
    └── ... (8个文件)
```

**报告输出**:
1. **数据分割报告**: 样本统计、质量检查
2. **DiBS学习报告**: 每层的因果图统计
3. **ATE计算报告**: 效应对比表
4. **权衡检测报告**: 跨场景权衡对比
5. **综合分析报告**: 核心发现和洞察

### 4.3 成功标准

**最低要求**:
- ✅ 8个分层子集的DiBS-ATE-权衡流程全部完成
- ✅ 至少发现一个场景差异的因果效应
- ✅ 验证交互项发现的至少一个现象

**理想成果**:
- 🎯 多个显著的场景差异效应
- 🎯 清晰的场景特定权衡模式
- 🎯 有实践意义的场景优化建议

---

## 5. 技术实现

### 5.1 代码架构

**新建脚本**:
1. `scripts/stratified/prepare_stratified_data.py` - 数据分割
2. `scripts/stratified/run_stratified_dibs.py` - DiBS学习
3. `scripts/stratified/run_stratified_ate.py` - ATE计算
4. `scripts/stratified/run_stratified_tradeoff.py` - 权衡检测
5. `scripts/stratified/compare_stratified_results.py` - 对比分析

**复用模块**:
- `utils/dibs.py` - DiBS学习（参数调整）
- `utils/causal_inference.py` - ATE计算（无需修改）
- `utils/tradeoff_detection.py` - 权衡检测（无需修改）

### 5.2 配置管理

**全局配置**: `configs/stratified_analysis_config.json`
```json
{
  "stratification_var": "is_parallel",
  "groups": ["group1_examples", "group3_person_reid", "group5_mrt_oast", "group6_resnet"],
  "layers": ["parallel_true", "parallel_false"],
  "dibs_params": {
    "threshold": 0.3,
    "sampling_iterations": 1000,
    "burnin": 200
  },
  "ate_params": {
    "confidence_level": 0.95,
    "n_splits": 5
  }
}
```

### 5.3 计算资源估计

**DiBS学习**:
- 8个独立模型 × 30-60分钟 = 4-8小时（串行）
- 可并行化 → 1-2小时（并行）

**ATE计算**:
- 8个因果图 × 5-30分钟 = 1-4小时

**总计算时间**: 5-12小时（串行），2-4小时（并行）

---

## 6. 风险与缓解

### 6.1 技术风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 小样本DiBS不收敛 | 中 | 高 | 调整prior参数，增加采样，使用简化模型 |
| ATE计算失败 | 低 | 中 | 使用备用估计方法（简化ATE） |
| 因果边太少 | 中 | 中 | 降低阈值至0.2，增加样本或合并组 |
| 计算时间过长 | 低 | 低 | 并行化，使用GPU加速 |

### 6.2 科学风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 场景差异不显著 | 中 | 中 | 仍有价值：否定交互项发现，确认全局分析充分 |
| 结果不稳定 | 低 | 高 | 交叉验证，敏感性分析，报告不确定性 |
| 因果图质量差 | 中 | 高 | 专家验证，边合理性检查，对比全局图 |

### 6.3 解释风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 过度解释差异 | 中 | 中 | 谨慎推断，强调置信区间，避免因果声明 |
| 忽略混杂因素 | 低 | 高 | 检查分层变量独立性，控制其他混淆 |
| 泛化性不足 | 高 | 低 | 明确限制结论范围，建议跨任务验证 |

---

## 7. 与现有分析的关系

### 7.1 与全局分析对比

| 维度 | 全局分析 | 分层分析 |
|------|----------|----------|
| 数据使用 | 混合所有场景 | 分离场景 |
| 平均效应 | 场景平均 | 场景特定 |
| 因果结构 | 单一图 | 两个图 |
| 适用性 | 场景无关决策 | 场景特定决策 |

### 7.2 与交互项分析对比

| 维度 | 交互项分析 | 分层分析 |
|------|------------|----------|
| 方法 | 单一图+交互项 | 两个独立图 |
| 假设 | 线性交互 | 完全结构差异 |
| 验证 | 间接（通过β₃） | 直接（对比两图） |
| 灵活性 | 结构固定 | 结构可变 |

**互补关系**:
- 交互项分析: 快速验证调节效应，单一模型
- 分层分析: 全面揭示结构差异，两个模型
- **建议**: 两种分析结合，交叉验证发现

---

## 8. 后续工作建议

### 8.1 本分析完成后的扩展

1. **其他分层变量**:
   - `model_architecture` (如ResNet vs BERT)
   - `task_type` (如分类 vs 检测)
   - `data_size` (大数据集 vs 小数据集)

2. **多变量分层**:
   - 同时按2-3个变量分层
   - 注意：样本量可能不足

3. **时序分层**:
   - 训练早期 vs 后期
   - 需要时序数据支持

### 8.2 方法论改进

1. **贝叶斯模型平均**: 结合全局和分层分析
2. **层级贝叶斯**: 部分 pooling，平衡场景差异和共享信息
3. **因果迁移学习**: 利用全局先验指导分层分析

---

## 9. 时间估计

| 阶段 | 时间 | 依赖 |
|------|------|------|
| 数据分割与验证 | 2-4小时 | - |
| DiBS学习（8组） | 4-8小时 | 数据分割 |
| ATE计算 | 1-4小时 | DiBS完成 |
| 权衡检测 | 1-2小时 | ATE完成 |
| 对比分析与报告 | 4-8小时 | 所有结果 |
| **总计** | **12-26小时** | - |

**建议**: 分阶段执行，每阶段验证后进入下一阶段

---

## 10. 验收标准

### 10.1 数据质量验收

- ✅ 8个分层子集数据完整性 > 95%
- ✅ 每层样本数 ≥ 30
- ✅ 无缺失值或已合理处理

### 10.2 分析完成验收

- ✅ 8个DiBS因果图成功学习
- ✅ 8个ATE计算成功完成
- ✅ 8个权衡检测成功执行
- ✅ 跨场景对比分析完成

### 10.3 科学价值验收

- ✅ 至少发现一个��著的场景差异效应
- ✅ 结果有统计学意义（CI不重叠）
- ✅ 发现可解释并有实践价值
- ✅ 报告清晰，方法透明

---

## 11. 附录

### 11.1 参考文档

- 交互项效应分析: `docs/reports/INTERACTION_EFFECT_ANALYSIS_REPORT_20260205.md`
- ATE修复验收: `docs/reports/ATE_CI_FIX_ACCEPTANCE_REPORT_20260203.md`
- 全局权衡检测: `docs/reports/ALGORITHM1_GLOBAL_STD_TRADEOFF_ACCEPTANCE_REPORT_20260203.md`

### 11.2 数据字典

**分层变量**:
- `is_parallel`: 布尔值，是否使用并行训练

**分层结果命名**:
- `{group}_parallel_true`: 并行场景子集
- `{group}_parallel_false`: 非并行场景子集

### 11.3 术语表

- **分层分析 (Stratified Analysis)**: 按某个变量将数据分为子集，分别分析
- **场景通用效应**: 在所有场景都存在的因果效应
- **场景特定效应**: 只在某个场景存在的因果效应
- **效应调节**: 效应大小随场景变化的现象

---

**方案制定时间**: 2026-02-05
**建议审核者**: 因果推断专家、统计学家、领域专家
**计划执行时间**: 待审核通过后开始
**预计完成时间**: 审核通过后1-2周

**签字**:
```
[方案制定者] - 资深科研工作者
[待审核] - 同行评审专家
[待批准] - 项目负责人
```
